#!/usr/bin/env python3

import json
import sys
import re
from textwrap import indent

IDL_TO_JSON_EXECUTABLE = './samples/idl_to_json'

# use 4 spaces for tab
TAB = ' ' * 4

# Special variable names
ITER = "__i"
RPCMEM_T = "__rpcmem_t"
MEM = "mem"
PACK = "__pack"
UNPACK = "__unpack"
SOCKET = "RPCSOCKET"

# includes

includes = """#include <stdio.h>
#include <string>
using namespace std;"""

proxyhelper = "#include \"rpcproxyhelper.h\""
stubhelper = "#include \"rpcstubhelper.h\""

boilerplate = '''#include "common/mem.h"
#include "common/basis.h"
#include "common/transmit.h"'''

basis_types = ["int", "float", "bool", "string", "rpcptr_t", "void"]


# expand basic C preprocessor "#include" templates in a string
def expand_includes(include: str) -> str:
    files_to_include = re.findall(r'#include "([\w\./]+)"', include)
    contents = []
    for filename in files_to_include:
        with open(filename, "r") as f:
            contents.append(f.read())
    contents = '\n'.join(contents)
    return re.sub(r'#include ".*"\s*\n', '', contents)


def check_usage(args: list[str]) -> str:
    if len(args) != 2 or not sys.argv[1].endswith(".idl"):
        sys.stderr.write("USAGE: ./rpcgenerate [filename.idl]")
        exit(1)
    return args[1]


# gen the common code across all proxies
def gen_proxy_boilerplate() -> str:
    socket = f"#define {SOCKET} RPCPROXYSOCKET"
    return '\n'.join([
        proxyhelper,
        socket,
        boilerplate
    ])


# gen the common code across all stubs
def gen_stub_boilerplate() -> str:
    socket = f"#define {SOCKET} RPCSTUBSOCKET"
    return '\n'.join([
        stubhelper,
        socket,
        boilerplate
    ])


# gets all the key value pairs for structs
def get_idl_struct_definitions(idl_json: dict) -> dict:
    return {t: v for t, v in idl_json["types"].items() if v['type_of_type'] == 'struct'}


# gets all the key value pairs for functions
def get_idl_function_declarations(idl_json: dict) -> dict:
    return idl_json["functions"]


# "x" "int" {"int" : ...} []        -> "__pack_int(x, mem);"
# "x" "int" {"int" : ...} [3]       -> "for (int i = 0; i < 3; i++)
#                                            __pack_int(x[i], mem);"
# "x" "int" {"int" : ...} [3, 4, 5] -> "for (int i = 0; i < 3 * 4 * 5; i++)
#                                            __pack_int(x[0][0][i], mem);"
def gen_pack(var, inner_typ, packers: dict[str, str], dims=None) -> str:
    if not inner_typ in packers and not inner_typ in basis_types:
        raise RuntimeError(f"Type {inner_typ} not previously declared")
    if inner_typ == 'void':
        return ""
    if dims:
        multiindex = "".join(["[0]" for _ in dims[1:]]) + f"[{ITER}]"
        return f"""for (int {ITER} = 0; {ITER} < {sumexp(dims)}; {ITER}++) {{
    {gen_pack(var + multiindex, inner_typ, packers)}
}}"""
    else:
        return f"{PACK}_{inner_typ}({var}, {MEM});"


# "x" "int" {"int" : ...} []        -> "x = __unpack_int(mem);"
# "x" "int" {"int" : ...} [3]       -> "for (int i = 3; i > 0; i--)
#                                           x[i - 1] = __unpack_int(mem);"
# "x" "int" {"int" : ...} [3, 4, 5] -> "for (int i = 3 * 4 * 5; i > 0; i--)
#                                           x[0][0][i - 1] = __unpack_int(mem);"
def gen_unpack(var, inner_typ, unpackers, dims=None) -> str:
    if not inner_typ in unpackers and not inner_typ in basis_types:
        raise RuntimeError(f"Type {inner_typ} not previously declared")
    if inner_typ == 'void':
        return ""
    if dims:
        multiindex = "".join(["[0]" for _ in dims[1:]]) + f"[{ITER} - 1]"
        return f"""for (int {ITER} = {sumexp(dims)}; {ITER} > 0; {ITER}--) {{
    {gen_unpack(var + multiindex, inner_typ, unpackers)}
}}"""
    else:
        return f"{var} = {UNPACK}_{inner_typ}({MEM});"


# int[3][4] -> int, [3, 4]
# int       -> int, []
def inner_type_and_dims(raw_type: str) -> tuple[str, list[int]]:
    if raw_type.startswith('__'):
        inner_type = re.sub(r"[_\]\[\d]", "", raw_type)
        dims = [int(dim) for dim in re.findall(r"\d+", raw_type)]
        return inner_type, dims
    return raw_type, []


# [3, 4, 5] -> 3 * 4 * 5
# [1] -> 1
def sumexp(nums: list[int]):
    return " * ".join([str(n) for n in nums])


def gen_packing_stmts(vars, types, packers) -> str:
    pack_stmts = []
    for var, typ in zip(vars, types):
        inner_typ, dims = inner_type_and_dims(typ)
        pack_stmts.append(gen_pack(var, inner_typ, packers, dims))
    return indent('\n'.join(pack_stmts), TAB)


def gen_unpacking_stmts(vars, types, unpackers) -> str:
    unpack_stmts = []
    for var, typ in zip(reversed(vars), reversed(types)):
        inner_typ, dims = inner_type_and_dims(typ)
        unpack_stmts.append(gen_unpack(var, inner_typ, unpackers, dims))
    return indent('\n'.join(unpack_stmts), TAB)


def gen_struct_packer(struct_name: str, struct_def: dict, packers: dict) -> str:
    struct_var = "bandhi"
    struct_members = [struct_var + '.' + member["name"]
                      for member in struct_def["members"]]
    struct_memtypes = [member["type"] for member in struct_def["members"]]
    packer_def = f"""
void {PACK}_{struct_name}({struct_name} {struct_var}, {RPCMEM_T} *{MEM}) {{
{gen_packing_stmts(struct_members, struct_memtypes, packers)}
}}"""
    return packer_def


def gen_struct_unpacker(struct_name: str, struct_def: dict, unpackers: dict) -> str:
    result_var = "result"
    result_members = [result_var + '.' + member["name"]
                      for member in struct_def["members"]]
    result_memtypes = [member["type"] for member in struct_def["members"]]
    unpacker_code = f"""
{struct_name} {UNPACK}_{struct_name}({RPCMEM_T} *{MEM}) {{
    {struct_name} {result_var};
{gen_unpacking_stmts(result_members, result_memtypes, unpackers)}
    return {result_var};
}}"""
    return unpacker_code


def type_space_name(arg):
    inner_typ, dims = inner_type_and_dims(arg["type"])
    return inner_typ + " " + arg["name"] + "".join([f"[{d}]" for d in dims])


def gen_proxy_def(function_name: str, func_decl: dict, packers: dict, unpackers: dict) -> str:
    arguments = func_decl["arguments"]
    argnames = [a["name"] for a in arguments]
    argtys = [a["type"] for a in arguments]
    return_type = func_decl["return_type"]
    result_var = "result"

    unpack_result = f"{return_type} {gen_unpack(result_var, return_type, unpackers)}" if return_type != "void" else ""
    return_result = f"return {result_var};" if return_type != "void" else ""

    params = ", ".join([type_space_name(a) for a in arguments])

    return f"""{return_type} {function_name}({params}) {{
    {RPCMEM_T} *{MEM} = rpcmem_new();

{gen_packing_stmts(argnames, argtys, packers)}

    rpc_send(\"{function_name.strip()}\", {MEM});
    rpc_recv({MEM});

    {unpack_result}

    rpcmem_free(&{MEM});
    {return_result}
}}
"""


def gen_stub_def(function_name: str, func_decl: dict, packers: dict, unpackers: dict) -> str:
    arguments = func_decl["arguments"]
    return_type = func_decl["return_type"]
    result_var = "result"

    argnames = [a["name"] for a in arguments]
    argtys = [a["type"] for a in arguments]

    arg_declarations = "\n".join([type_space_name(a) + ';' for a in arguments])

    save_result = ""
    if return_type != "void":
        save_result = f"{return_type} {result_var} = "

    return f"""void __{function_name}({RPCMEM_T} *{MEM}) {{
{indent(arg_declarations, TAB)}
{gen_unpacking_stmts(argnames, argtys, unpackers)}

    {save_result}{function_name}({", ".join(argnames)});
    {MEM}->hp = 0;
    {MEM}->sp = {MEM}->capacity;

    {gen_pack(result_var, return_type, packers)}
}}
"""


def match_and_invoke_stub_methods(func_decls: dict) -> str:
    dispatcher_code = ""
    for function_name in func_decls.keys():
        dispatcher_code += f"""
if (fname == "{function_name}") {{
    __{function_name}({MEM});
    goto respond;
}}
"""
    return dispatcher_code


def gen_stub_dispatcher(func_decls: dict) -> str:
    return f"""
// Stub dispatcher
void dispatchFunction() {{
    {RPCMEM_T} *{MEM} = rpcmem_new();
    string fname = rpc_recv({MEM});
    if (fname == NO_RPC)
        return;
    
    {indent(match_and_invoke_stub_methods(func_decls), TAB)}
    // no match (matches use `goto respond`)
    {MEM}->sp = {MEM}->capacity;
    {MEM}->hp = 0;
    fname = "BAD";

respond:
    rpc_send(fname, {MEM});
    rpcmem_free(&{MEM});
}}
"""


def write_proxy(proxy_code: str, idl_filename: str):
    with open(re.sub(r'\.idl', '.proxy.cpp', idl_filename), 'w') as f:
        f.write(proxy_code)


def write_stub(stub_code: str, idl_filename: str):
    with open(re.sub(r'\.idl', '.stub.cpp', idl_filename), 'w') as f:
        f.write(stub_code)


def main():
    idl_filename = check_usage(sys.argv)
    idl_json = {}
    with open(re.sub(r'\.idl', '.json', idl_filename), "r") as f:
        idl_json = json.load(f)
    idl_include = f"#include \"{idl_filename}\""

    proxy_boilerplate = gen_proxy_boilerplate()
    stub_boilerplate = gen_stub_boilerplate()

    struct_defs = get_idl_struct_definitions(idl_json)  # python objects
    func_decls = get_idl_function_declarations(idl_json)  # python objects

    packers = {}
    unpackers = {}
    for name, struct_def in reversed(struct_defs.items()):
        packers[name] = gen_struct_packer(name, struct_def, packers)
        unpackers[name] = gen_struct_unpacker(name, struct_def, unpackers)

    packer_funcs = "\n".join(packers.values())
    unpacker_funcs = "\n".join(unpackers.values()) + '\n'
    proxy_funcs = "".join([gen_proxy_def(name, dec, packers, unpackers) + '\n'
                           for name, dec in func_decls.items()])
    stub_funcs = "".join([gen_stub_def(name, dec, packers, unpackers) + '\n'
                          for name, dec in func_decls.items()])

    stub_dispatcher = gen_stub_dispatcher(func_decls)

    proxy_code = '\n'.join([includes, idl_include, proxy_boilerplate,
                            packer_funcs, unpacker_funcs, proxy_funcs])
    stub_code = '\n'.join([includes, idl_include, stub_boilerplate,
                           packer_funcs, unpacker_funcs, stub_funcs,
                           stub_dispatcher])

    write_proxy(proxy_code, idl_filename)
    write_stub(stub_code, idl_filename)


if __name__ == '__main__':
    main()
