#!/usr/bin/env python3
import subprocess
import json
import sys
import os

IDL_TO_JSON_EXECUTABLE = './idl_to_json'

# Given an idl filename, convert the IDL to a JSON object, and return it
# changed read_idl_to_json(str) ==> read_idl_to_json()
def read_idl_to_json() -> dict:
    try:
    #
    #     Make sure invoked properly
    #
        assert len(sys.argv) == 2, "Wrong number of arguments"

        #
        #     Make sure IDL file exists and is readable
        #
        filename = sys.argv[1]
        assert os.path.isfile(filename), f"Path {filename} does not designate a file"
        assert os.access(filename, os.R_OK), f"File {filename} is not readable" 

        #
        #     Make sure idl_to_json exists and is executable
        #
        assert os.path.isfile(IDL_TO_JSON_EXECUTABLE), f"Path {IDL_TO_JSON_EXECUTABLE} does not designate a file...run \"make\" to create it" 
        assert os.access(IDL_TO_JSON_EXECUTABLE, os.X_OK), f"File {IDL_TO_JSON_EXECUTABLE} exists but is not executable"

        #
        #     Parse declarations into a Python dictionary
        #
        decls = json.loads(subprocess.check_output([IDL_TO_JSON_EXECUTABLE, filename]))

        #
        # Loop printing each function signature
        #
        #print(decls)
        return decls

    except Exception as e:
        print(str(e), file=sys.stderr)
        print(f"Usage: {sys.argv[0]} <idlfilename>", file=sys.stderr)
        pass

includes = """
#include <stdio.h>
#include <string>
using namespace std;
"""

basis_types_boilerplate = """
#include "common/basis.h"
"""

mem_boilerplate = """
#include "common/mem.h"
"""

transmit_boilerplate = """
#include "common/transmit.h"
"""

def gen_proxy_boilerplate() -> str:
    return '\n'.join([ basis_types_boilerplate, mem_boilerplate, transmit_boilerplate])


def gen_stub_boilerplate() -> str:
    return '\n'.join([ basis_types_boilerplate, mem_boilerplate, transmit_boilerplate])


def get_idl_struct_definitions(idl_json: dict) -> dict:
    types = idl_json["types"]
    return [t for t in types if t['type_of_type'] == 'struct']

def get_idl_function_declarations(idl_json: dict) -> dict:
    return idl_json["functions"]


def gen_basis_types_packers() -> dict:
    return {
        "int": "",
        "float": "",
        "bool": "",
        "rpcptr_t": "",
        "string": "",
    }

def gen_basis_types_unpackers() -> dict:
    return {
        "int": "",
        "float": "",
        "bool": "",
        "rpcptr_t": "",
        "string": "",
    }

def gen_one_pack(var, type, packers):
    if not type in packers:
        raise Exception(f"Type {type} not previously declared")
    return f"pack_{type}({var}, mem))"

def gen_one_unpack(var, type, unpackers):
    if not type in unpackers:
        raise Exception(f"Type {type} not previously declared")
    return f"{var} = unpack_{type}(mem)"

def gen_packing_code(var, struct_def, packers):
    """
    Assumes an `rpcmem_t *MEM` is in scope.
    Generates the C++ statements to pack the type.
    """
    pack_stmts = []
    for member in struct_def["members"]:
        member_name = member["name"]
        member_type = member["type"]
        if 
        pack_stmts.append(f"{var}.{member_name}", member_type, packers)

def gen_unpacking_code(var, struct_def, unpackers):
    """
    Assumes an `rpcmem_t *MEM`, and `<type> result` is in scope.
    Generates the C++ statements to unpack the type.
    """
    pass

def gen_struct_packer(struct_name: str, struct_def: dict, packers: dict) -> str:
    if not struct_name in packers:
        raise Exception(f"Struct {struct_name} not previously declared")
    struct_var = "bandhi"
    packer_def = f"""
    void pack_{struct_name}({struct_name} {struct_var}, rpcmem_t *MEM) {{
        {gen_packing_code(struct_var, struct_def, packers)}
    }}
    """
    return packer_def


def gen_struct_unpacker(struct_name: str, struct_def: dict, unpackers: dict) -> str:
    if not struct_name in unpackers:
        raise Exception(f"Struct {struct_name} not previously declared")

    unpacker_code = f"""
    {struct_name} unpack_{struct_name}(rpcmem_t *MEM) {{
        {struct_name} result;
        {gen_unpacking_code("result", struct_def, unpackers[struct_name])}
        return result;
    }}
    """
    return unpacker_code


def stringify_arguments(arguments):
    return ""


def gen_proxy_def(func_decl: dict, packers: dict, unpackers: dict) -> str:
    function_name = func_decl[function_name]
    arguments = func_decl[arguments]
    return_type = func_decl[return_type]

    arguments_string = stringify_arguments(arguments)

    declare_result = f"{return_type} result;" if return_type != "void" else ""
    return_result = f"return result;" if return_type != "void" else ""

    f"""
    {return_type} {function_name}({arguments_string}) {{
        {declare_result}
        rpcmem_t *MEM = rpcmem_new();
        {gen_packing_code(arguments)}
        rpc_send(\"{function_name}\", MEM);
        rpc_receive(MEM);
        {gen_unpacking_code(return_type, unpackers)}
        rpcmem_free(&MEM);
        {return_result}
    }}
    """
    pass


def gen_stub_def(func_decl: dict, packers: dict, unpackers: dict) -> str:
    function_name = func_decl["function_name"]
    arguments = func_decl["arguments"]
    return_type = func_decl["return_type"]

    arguments_string = stringify_arguments(arguments)
    return f"""
    {return_type} {function_name}({arguments_string}, rpcmem_t *MEM) {{
        rpcmem_t *MEM = rpcmem_new();
        {gen_unpacking_code()}
        {function_name}({arguments});
        {gen_packing_code()}
    }}
    """
    pass


def gen_stub_dispatcher(func_decls: list[dict]) -> str:
    pass


def write_proxy(proxy_code: str, idl_filename: str):
    with open(f"{idl_filename.removesuffix('.idl')}.proxy.cpp", 'w') as f:
        f.write(proxy_code)


def write_stub(stub_code: str, idl_filename: str):
    with open(f"{idl_filename.removesuffix('.idl')}.stub.cpp", 'w') as f:
        f.write(stub_code)


def extract_function_defs(packers: dict) -> list[str]:
    return []


if __name__ == '__main__':
    idl_filename = sys.argv[1]
    idl_json = read_idl_to_json(idl_filename)
    idl_include = f"#include \"{idl_filename}\""

    proxy_boilerplate = gen_proxy_boilerplate()
    stub_boilerplate = gen_stub_boilerplate()

    struct_defs = get_idl_struct_definitions(idl_json) #python objects
    func_decls = get_idl_function_declarations(idl_json) #python objects

    # TBD what these actually contain
    packers: dict = gen_basis_types_packers()
    unpackers: dict = gen_basis_types_unpackers()
    for name, struct_def in struct_defs:
        packers[name] = gen_struct_packer(name, struct_def, packers)
        unpackers[name] = gen_struct_unpacker(name, struct_def, unpackers)

    proxy_funcs = [gen_proxy_def(f, packers, unpackers) for f in func_decls]
    stub_funcs = [gen_stub_def(f, packers, unpackers) for f in func_decls]

    stub_dispatcher = gen_stub_dispatcher(func_decls)

    packer_defs = packers.values()
    unpacker_defs = unpackers.values()

    proxy_code = '\n'.join(
        [idl_include, proxy_boilerplate, packer_defs, unpacker_defs, proxy_funcs].flatten())
    stub_code = '\n'.join(
        [idl_include, stub_boilerplate, packer_defs, unpacker_defs, stub_funcs, stub_dispatcher].flatten())

    write_proxy(proxy_code, idl_filename)
    write_stub(stub_code, idl_filename)

    print(idl_filename)
