#!/usr/bin/env python3

import subprocess
import json
import sys
import re
import os
from textwrap import indent

IDL_TO_JSON_EXECUTABLE = './samples/idl_to_json'

# use 4 spaces for tab
TAB = ' ' * 4

# Special variable names
ITER = "__i"
RPCMEM_T = "__rpcmem_t"
MEM = "mem"
PACK = "__pack"
UNPACK = "__unpack"
SOCKET = "RPCSOCKET"

# includes

includes = """#include <stdio.h>
#include <string>
using namespace std;"""

proxyhelper = "#include \"rpcproxyhelper.h\""
stubhelper = "#include \"rpcstubhelper.h\""

boilerplate = '''#include "common/mem.h"
#include "common/basis.h"
#include "common/transmit.h"'''

basis_types = ["int", "float", "bool", "string", "rpcptr_t", "void"]


def expand_includes(include: str):
    files_to_include = re.findall(r'#include "([\w\./]+)"', include)
    contents = []
    for filename in files_to_include:
        with open(filename, "r") as f:
            contents.append(f.read())
    contents = '\n'.join(contents)
    return re.sub(r'#include ".*"\s*\n', '', contents)


def check_usage(args):
    if len(args) != 2 or not sys.argv[1].endswith(".idl"):
        sys.stderr.write("USAGE: ./rpcgenerate [filename.idl]")
        exit(1)
    return args[1]


def gen_proxy_boilerplate() -> str:
    socket = f"#define {SOCKET} RPCPROXYSOCKET"
    return '\n'.join([
        proxyhelper,
        socket,
        boilerplate
    ])


def gen_stub_boilerplate() -> str:
    socket = f"#define {SOCKET} RPCSTUBSOCKET"
    return '\n'.join([
        stubhelper,
        socket,
        boilerplate
    ])


def get_idl_struct_definitions(idl_json: dict) -> dict:
    types = idl_json["types"]
    return {t: v for t, v in types.items() if v['type_of_type'] == 'struct'}


def get_idl_function_declarations(idl_json: dict) -> dict:
    return idl_json["functions"]


def gen_pack(var, typ, packers, dims=None) -> str:
    if not typ in packers and not typ in basis_types:
        raise RuntimeError(f"Type {typ} not previously declared")
    if typ == 'void':
        return ""
    if dims:
        multiindex = "".join(["[0]" for _ in dims[1:]]) + f"[{ITER}]"
        return f"""for (int {ITER} = 0; {ITER} < {sumexp(dims)}; {ITER}++) {{
    {gen_pack(var + multiindex, typ, packers)}
}}"""
    else:
        return f"{PACK}_{typ}({var}, {MEM});"


def gen_unpack(var, typ, unpackers, dims=None) -> str:
    if not typ in unpackers and not typ in basis_types:
        raise RuntimeError(f"Type {typ} not previously declared")
    if typ == 'void':
        return ""
    if dims:
        multiindex = "".join(["[0]" for _ in dims[1:]]) + f"[{ITER} - 1]"
        return f"""for (int {ITER} = {sumexp(dims)}; {ITER} > 0; {ITER}--) {{
    {gen_unpack(var + multiindex, typ, unpackers)}
}}"""
    else:
        return f"{var} = {UNPACK}_{typ}({MEM});"


def inner_type_and_dims(raw_type: str) -> tuple[str, list[int]]:
    if raw_type.startswith('__'):
        inner_type = re.sub(r"[_\]\[\d]", "", raw_type)
        dims = [int(dim) for dim in re.findall(r"\d+", raw_type)]
        return inner_type, dims
    return raw_type, []


def sumexp(nums: list[int]):
    return " * ".join([str(n) for n in nums])


def gen_packing_stmts(vars, types, packers) -> str:
    pack_stmts = []
    for var, typ in zip(vars, types):
        inner_typ, dims = inner_type_and_dims(typ)
        pack_stmts.append(gen_pack(var, inner_typ, packers, dims))
    return indent('\n'.join(pack_stmts), TAB)


def gen_unpacking_stmts(vars, types, unpackers) -> str:
    unpack_stmts = []
    for var, typ in zip(reversed(vars), reversed(types)):
        inner_typ, dims = inner_type_and_dims(typ)
        unpack_stmts.append(gen_unpack(var, inner_typ, unpackers, dims))
    return indent('\n'.join(unpack_stmts), TAB)


def gen_struct_packer(struct_name: str, struct_def: dict, packers: dict) -> str:
    struct_var = "bandhi"
    struct_members = [struct_var + '.' + member["name"]
                      for member in struct_def["members"]]
    struct_memtypes = [member["type"] for member in struct_def["members"]]
    packer_def = f"""
void {PACK}_{struct_name}({struct_name} {struct_var}, {RPCMEM_T} *{MEM}) {{
{gen_packing_stmts(struct_members, struct_memtypes, packers)}
}}"""
    return packer_def


def gen_struct_unpacker(struct_name: str, struct_def: dict, unpackers: dict) -> str:
    result_var = "result"
    result_members = [result_var + '.' + member["name"]
                      for member in struct_def["members"]]
    result_memtypes = [member["type"] for member in struct_def["members"]]
    unpacker_code = f"""
{struct_name} {UNPACK}_{struct_name}({RPCMEM_T} *{MEM}) {{
    {struct_name} {result_var};
{gen_unpacking_stmts(result_members, result_memtypes, unpackers)}
    return {result_var};
}}"""
    return unpacker_code


def type_space_name(arg):
    inner_typ, dims = inner_type_and_dims(arg["type"])
    return inner_typ + " " + arg["name"] + "".join([f"[{d}]" for d in dims])


def gen_proxy_def(function_name: str, func_decl: dict, packers: dict, unpackers: dict) -> str:
    arguments = func_decl["arguments"]
    argnames = [a["name"] for a in arguments]
    argtys = [a["type"] for a in arguments]
    return_type = func_decl["return_type"]
    result_var = "result"

    unpack_result = f"{return_type} {gen_unpack(result_var, return_type, unpackers)}" if return_type != "void" else ""
    return_result = f"return {result_var};" if return_type != "void" else ""

    params = ", ".join([type_space_name(a) for a in arguments])

    return f"""{return_type} {function_name}({params}) {{
    {RPCMEM_T} *{MEM} = rpcmem_new();

    ERP("PACKING %s\\n", "{function_name}");
    DEBUGMEM({MEM});

{gen_packing_stmts(argnames, argtys, packers)}

    DEBUGMEM({MEM});
    rpc_send(\"{function_name}\", {MEM});
    rpc_recv({MEM});

    ERP("UNPACKING retval %s\\n", "{function_name}");
    DEBUGMEM({MEM});

    {unpack_result}

    DEBUGMEM({MEM});
    rpcmem_free(&{MEM});
    {return_result}
}}
"""


def gen_stub_def(function_name: str, func_decl: dict, packers: dict, unpackers: dict) -> str:
    arguments = func_decl["arguments"]
    return_type = func_decl["return_type"]
    result_var = "result"

    argnames = [a["name"] for a in arguments]
    argtys = [a["type"] for a in arguments]

    arg_declarations = "\n".join([type_space_name(a) + ';' for a in arguments])

    save_result = ""
    if return_type != "void":
        save_result = f"{return_type} {result_var} = "

    return f"""void __{function_name}({RPCMEM_T} *{MEM}) {{
{indent(arg_declarations, TAB)}

    ERP("UNPACKING %s\\n", "{function_name}");
    DEBUGMEM({MEM});

{gen_unpacking_stmts(argnames, argtys, unpackers)}

    DEBUGMEM({MEM});

    {save_result}{function_name}({", ".join(argnames)});
    {MEM}->hp = 0;
    {MEM}->sp = {MEM}->capacity;

    ERP("PACKING RETURNVAL %s\\n", "{function_name}");
    DEBUGMEM({MEM});

    {gen_pack(result_var, return_type, packers)}

    DEBUGMEM({MEM});
}}
"""


def match_and_invoke_stub_methods(func_decls: dict) -> str:
    dispatcher_code = ""
    for function_name in func_decls.keys():
        dispatcher_code += f"""
if (strcmp(fname.c_str(), "{function_name}") == 0) {{
    ERP("%s matches %s\\n", fname.c_str(), "{function_name}");
    __{function_name}({MEM});
    ERP("just finished exec and now: ");
    DEBUGMEM({MEM});
    ERP("should have just printed debugmem\\n");
    goto respond;
}}
"""
    return dispatcher_code


def gen_stub_dispatcher(func_decls: dict) -> str:
    return f"""
// Stub dispatcher
void dispatchFunction() {{
    {RPCMEM_T} *{MEM} = rpcmem_new();

    ERP("starting recv\\n");

    string fname = rpc_recv({MEM});

    ERP("finished recv\\n");

    DEBUGMEM({MEM});
    DEBUG("TRYING TO MATCH %s", fname.c_str());

    {indent(match_and_invoke_stub_methods(func_decls), TAB)}

    ERP("didn't match any funcs\\n");
    {MEM}->sp = {MEM}->capacity;
    {MEM}->hp = 0;
    fname = "BAD";

respond:
    ERP("exec finished, responding \\n");
    DEBUGMEM({MEM});
    rpc_send(fname, {MEM});
    rpcmem_free(&{MEM});
}}
"""


def write_proxy(proxy_code: str, idl_filename: str):
    with open(re.sub(r'\.idl', '.proxy.cpp', idl_filename), 'w') as f:
        f.write(proxy_code)


def write_stub(stub_code: str, idl_filename: str):
    with open(re.sub(r'\.idl', '.stub.cpp', idl_filename), 'w') as f:
        f.write(stub_code)


def main():
    idl_filename = check_usage(sys.argv)
    idl_json = {}
    with open(re.sub(r'\.idl', '.json', idl_filename), "r") as f:
        idl_json = json.load(f)
    idl_include = f"#include \"{idl_filename}\""

    proxy_boilerplate = gen_proxy_boilerplate()
    stub_boilerplate = gen_stub_boilerplate()

    struct_defs = get_idl_struct_definitions(idl_json)  # python objects
    func_decls = get_idl_function_declarations(idl_json)  # python objects

    packers = {}
    unpackers = {}
    for name, struct_def in reversed(struct_defs.items()):
        packers[name] = gen_struct_packer(name, struct_def, packers)
        unpackers[name] = gen_struct_unpacker(name, struct_def, unpackers)

    packer_funcs = "\n".join(packers.values())
    unpacker_funcs = "\n".join(unpackers.values()) + '\n'
    proxy_funcs = "".join([gen_proxy_def(name, dec, packers, unpackers) + '\n'
                           for name, dec in func_decls.items()])
    stub_funcs = "".join([gen_stub_def(name, dec, packers, unpackers) + '\n'
                          for name, dec in func_decls.items()])

    stub_dispatcher = gen_stub_dispatcher(func_decls)

    proxy_code = '\n'.join([includes, idl_include, proxy_boilerplate,
                            packer_funcs, unpacker_funcs, proxy_funcs])
    stub_code = '\n'.join(
        [includes, idl_include, stub_boilerplate, packer_funcs, unpacker_funcs, stub_funcs, stub_dispatcher])

    write_proxy(proxy_code, idl_filename)
    write_stub(stub_code, idl_filename)


if __name__ == '__main__':
    main()
